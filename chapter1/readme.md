### 数据结构和算法
---
#### 解压序列赋值给多个变量
- 变量的数量必须跟序列元素的数量是一样的。否则会爆一下错误`ValueError: too many values to unpack (expected 2)`
#### 解压可迭代对象赋值给多个变量
- 解压赋值可以应用在任何的迭代对象上，例如字符串
#### 保留最后N个元素
- 只想获取部分序列中的数据，可以通过使用占位符来实现
- 可以使用星号表达式获取多个数据，并返回一个列表类型- 
- 星号表达式解压序列，可以获取序列中前、中、后的多个数据
- deque当大于设定队列大小时，它会抛弃最先插入的数据
#### 实现一个优先级队列
- heapq通过nlargest获取队列中最大几个数，nsmallest获取最小几个数。实现这个的本质是通过内部heapify函数先将数据排序
- heapq实现排序需要内部数据拥有可比较的对象，比如数字
#### 字典中映射多个值
- defaultdict解决了字典多值类型初始类型和初始key的问题
#### 字典排序
- OrdereDict创建有序字典，它所消耗的内存大小是原字典的两倍
#### 在两个字典中寻找相同点
- dict.keys()会返回dict_keys对象,支持与或等逻辑操作
- dict.items()会返回dict_items对象，支持与或等逻辑操作
#### 从序列中移除重复项且保持元素间顺序不变
- 善用匿名函数，使用匿名函数作为参数实现对函数输入数据的动态处理
- 使用`in`判断是否存在对应值的方式仅支持可hash对象。非hash对象需要处理成hash对象后再进行处理
- 集合元素唯一，但不保证它们之间的顺序
#### 对切片命名
- 使用`slice`实例使切片命名，让程序可读性更良好
- 使用`indices(size)`，让切片参数不溢出
#### 找出序列中出现次数最多的元素
- `collections.Counter`可以统计任意可hash对象的出现频率
- `collections.Counter`可进行加减操作，来计算频率
#### 通过公共键对字典列表排序
- `operator.itemgetter`函数可以根据key获取值并返回排序依据值
- 它的效率高于匿名函数
- 它的参数是所有可以传给`__getitem__()`的值
#### 对不原生支持比较操作的对象排序
- `sorted()`函数接收一个用来传递可调用对象(callable)的参数key，而该可调用对象会返回待排序对象的某些值
- 匿名函数和`itemgetter`可以用来创建这个可调用对象
#### 根据字段将记录分组
- `itertools.groupby`返回一个迭代器，每次迭代会返回一个值和一个子迭代器。它只能检查连续值并成组，所以先要进行排序
- 如果不考虑内存消耗可以用一键多值字典来进行分组