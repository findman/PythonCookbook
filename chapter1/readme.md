### 数据结构和算法
---
#### 解压序列赋值给多个变量
- 变量的数量必须跟序列元素的数量是一样的。否则会爆一下错误`ValueError: too many values to unpack (expected 2)`
#### 解压可迭代对象赋值给多个变量
- 解压赋值可以应用在任何的迭代对象上，例如字符串
#### 保留最后N个元素
- 只想获取部分序列中的数据，可以通过使用占位符来实现
- 可以使用星号表达式获取多个数据，并返回一个列表类型- 
- 星号表达式解压序列，可以获取序列中前、中、后的多个数据
- deque当大于设定队列大小时，它会抛弃最先插入的数据
#### 实现一个优先级队列
- heapq通过nlargest获取队列中最大几个数，nsmallest获取最小几个数。实现这个的本质是通过内部heapify函数先将数据排序
- heapq实现排序需要内部数据拥有可比较的对象，比如数字
#### 字典中映射多个值
- defaultdict解决了字典多值类型初始类型和初始key的问题
#### 字典排序
- OrdereDict创建有序字典，它所消耗的内存大小是原字典的两倍
#### 在两个字典中寻找相同点
- dict.keys()会返回dict_keys对象,支持与或等逻辑操作
- dict.items()会返回dict_items对象，支持与或等逻辑操作
#### 从序列中移除重复项且保持元素间顺序不变
- 善用匿名函数，使用匿名函数作为参数实现对函数输入数据的动态处理
- 使用`in`判断是否存在对应值的方式仅支持可hash对象。非hash对象需要处理成hash对象后再进行处理
- 集合元素唯一，但不保证它们之间的顺序
#### 对切片命名
- 使用`slice`实例使切片命名，让程序可读性更良好
- 使用`indices(size)`，让切片参数不溢出
#### 找出序列中出现次数最多的元素
- `collections.Counter`可以统计任意可hash对象的出现频率
- `collections.Counter`可进行加减操作，来计算频率
#### 通过公共键对字典列表排序
- `operator.itemgetter`函数可以根据key获取值并返回排序依据值
- 它的效率高于匿名函数
- 它的参数是所有可以传给`__getitem__()`的值
#### 对不原生支持比较操作的对象排序
- `sorted()`函数接收一个用来传递可调用对象(callable)的参数key，而该可调用对象会返回待排序对象的某些值
- 匿名函数和`itemgetter`可以用来创建这个可调用对象
#### 根据字段将记录分组
- `itertools.groupby`返回一个迭代器，每次迭代会返回一个值和一个子迭代器。它只能检查连续值并成组，所以先要进行排序
- 如果不考虑内存消耗可以用一键多值字典来进行分组
#### 筛选序列中的元素
- 无比强大的列表推导式
    ```
    # 列表推导式完整应用
    #
    #        数据转换
    #           |           数据替换
    #           |              |             数据源
    #           |              |               |         数据筛选
    #           |              |               |            |
    #      ============ =============== =============== =========
    print([math.sqrt(n) if n > 0 else 0 for n in mylist if n > -7])
    ```
- `from itertools import compress`它的依据第二个参数传入的序列筛选第一个序列
#### 从字典中提取子集
- 字典推导式类似列表推导式
- 字典推导式效率最优
#### 将名称映射到序列的元素中
- `namedtuple`可以对一个序列进行命名映射，生成一个命名元组对象
- 命名元组只读
- 需要修改命名元组中的值可用`_replace()`函数
- 让原命名元组`_replace()`模板命名元组实现填充具有可选或缺失的命名元组
#### 同时对数据做转换和计算
- 和列表推导式类似